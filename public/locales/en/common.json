{
	"header": {
		"about": "About me",
		"skills": "Skills",
		"projects": "Projects",
		"contact": "Contact me",
		"connect": "Let's connect"
	},
	"hero": {
		"greet": "Hi, I'm",
		"banner": {
			"developer": "Full Stack Developer",
			"engineer": "System Engineer"
		},
		"skills": "I can develop full-stack applications with technologies like JavaScript, TypeScript, React, Node, Express, Nest, PostgreSQL, or MongoDB",
		"cv": "Download CV"
	},
	"about": {
		"title": "About me",
		"first_p": "My journey into the programming world began at college with my first programming classes. At that time, I believed programmers were some class of hackers, and my knowledge of web development and programming was practically nil. In this way,  I learned the basic notions of programming through C++ language, developing small programs executed in the console. Subsequently, I began to study HTML, CSS, JavaScript, and PHP to build more complex programs with attractive user interfaces to fulfill the assigned projects at the university.",
		"second_p": "Therefore, the first project I made to practice these technologies was a small repository to organize and store the data required to help people opt for bonuses provided by the government through a website. Later, at the end project, I felt immense satisfaction because I realized I could develop software helpful for people. Since then, I decided to specialize in web development, learning both self-taught and through courses and bootcamps."
	},
	"skills": {
		"title": "Skills",
		"first_p": "At university, I learned basic programming and more advanced concepts like object-oriented programming, data structures, algorithms, and recursion, along with basic concepts of software engineering, such as the case of the software life cycle, starting from the analysis to the design and implementation of systems. On the other hand, I have finished courses like",
		"&": "and",
		"second_p": ", in addition to learning other technologies, frameworks, and libraries with free resources such as YouTube or the documentation of said technologies.",
		"second_t": "Main technologies"
	},
	"projects": {
		"title": "Projects",
		"action": "View project",
		"web_access": {
			"desc": "Automatic web accessibility evaluation tool and contrast checker"
		},
		"sticky_notes": {
			"desc": "Notes app with internationalization."
		},
		"coroshop": {
			"desc": "E-commerce with Stripe or PayPal payments."
		},
		"titles": {
			"origin": "Idea origin",
			"development": "Development process",
			"challenges": "Challenges during development",
			"learning": "Learning"
		},
		"other": "Another projects"
	},
	"contact": {
		"title": "Contact me",
		"form": {
			"f_name": "First name",
			"s_name": "Last name",
			"email": "Email address",
			"message": "Message",
			"send": "Send",
			"success": "Message sent successfully!",
			"fail": "Can not sent message!"
		}
	},
	"footer": {
		"copy": "Copyright by Joan Romero 2022",
		"rights": "All rights reserved"
	},
	"visit": "View",
	"web_access": {
		"desc": "WebAccess is a website that has two tools to help web developers create more accessible content. The first tool is an automatic web accessibility evaluator, which allows the evaluation of HTML code by inserting the URL of a web page or the HTML code itself, applying up to 13 techniques proposed by the WCAG in its version 2.1. On the other hand, the second tool is a contrast evaluator, which allows knowing if the contrast ratio between two colors (text and background) meets any of the levels established by the WCAG.",
		"stack": {
			"desc": "On the frontend side, I used React as the base framework, SASS for the styles, and managed the state with hooks and Jotai due to its simplicity and because it avoids unnecessary renderings.  On the other hand, I developed the backend with Express in addition to a library called Cheerio, which has a simple API to manipulate and analyze the DOM of an HTML document."
		},
		"origin": {
			"desc": "The idea of ​​developing an automatic accessibility evaluation tool arose when I was looking for topics to focus on for my thesis at university. While learning web development, I could notice that the subject of accessibility was approached in a limited way or even omitted, so I decided to focus my thesis on this topic. In this way, I researched automatic accessibility evaluation tools and noticed that it was feasible to make a prototype, so I focused my thesis on its development. In this prototype, the evaluation focused on visual disabilities and developed views with EJS, which allows inserting JavaScript code into HTML. Later, to consolidate the knowledge I acquired of React and web development in general, I decided to make this second version, improving the quality of the initial prototype."
		},
		"development": {
			"f_desc": "The first step was to analyze and filter the techniques proposed by the WCAG related to HTML that I could apply with Cheerio. Subsequently, I began to develop the backend, conformed by a REST API with routes to evaluate by URL and HTML code, in addition to each function to evaluate the selected WCAG techniques. It is also important to highlight that I perform unit tests on all techniques functions, besides integration tests on each API route.",
			"s_desc": "As for the front, I started by making a preliminary design in Figma, selecting the color palette and the font styles for the user interfaces built with React and SASS. In this way, the first screens developed were the homepage and the page to select the type of accessibility evaluation. Later, I build the results screen, in addition to the hook in charge of handling the API request status. Finally, I did develop the contrast evaluation screen and the necessary Jotai atoms for the state."
		},
		"challenges": {
			"desc": "Regarding the backend, the main challenge I found was how to perform the functions to apply each WCAG technique with the Cheerio library in the most efficient way possible to avoid long API response times. Finally, I found it hard to decide when it was correct to abstract a component to reuse its behavior or style."
		},
		"learning": {
			"f_desc": "I learned important practices during the development of the project. For example, it is always better to have simple code, so you should not be obsessed with performance in the early stages of the project because you could tend to apply over-engineering and write more complex code than necessary. Finally, I learned to perform unit and integration tests and the importance of writing more semantic HTML code, along with other aspects related to web accessibility."
		}
	},
	"sticky_notes": {
		"desc": "Sticky Notes is a note app with the functions of creating, editing, archiving, and deleting notes. In addition, it allows you to assign a color to the notes allowing categorize and filter them, including the ability to search both by title and body of the note. Finally, the application has internationalization (English and Spanish) and a basic JWT-based authentication system.",
		"stack": {
			"f_desc": "I writhe the entire application in TypeScript due to the advantages of having strongly typed code, such as error prevention during development. On the frontend side, I used React as the base framework, mainly using React-Query to manage the state since this library facilitates the coordination and synchronization of the state or cache of the server, which makes up most of the state of the application, plus hooks and Jotai to handle the remaining state. For styles, I use Material UI because it provides customizable components that make it easy to create an attractive and professional user interface in less time.",
			"s_desc": "On the other hand, the backend was built on Express due to its ease and flexibility to create a REST API, in addition to PostgreSQL as a database, since it is one of the most robust relational databases with great support. Finally, I use Prisma as ORM because it offers a powerful CLI and works with TypesCript by default, making it easy to create services with good type safety."
		},
		"origin": {
			"desc": "The idea of ​​developing Sticky Notes arises to take advantage of a basic notes application that I had made as part of a technical test in order to practice and consolidate the knowledge I had acquired of technologies such as TypeScript, React-Query, or Prisma. The original app was written in JavaScript, using Sequelize as the ORM and Bootstrap to style the UI. Also, it is important to note that the original application did not have an authentication system either."
		},
		"development": {
			"f_desc": "In the development of the first version, it was not necessary to make a preliminary design for the user interface because the test included a basic design, so I focused on preparing the tables for the database. Later, to start with the second version, I begin by migrating the backend code to TypeScript and then redesigning the database to add the necessary tables for the authentication functions and sorting by color. The last steps regarding the backend were migrating from Sequelize to Prisma as ORM and adding or modifying the drivers and services needed to implement the new features.",
			"s_desc": "In the front, I started by migrating the code to TypeScript and the styles to Material UI, adding interactive components like modal windows. Finally, I added and modified some components to implement authentication, color filtering, search functions, and internationalization."
		},
		"challenges": {
			"f_desc": "One of the biggest challenges I faced was typing third-party library utilities with TypeScript because sometimes they required a specific type that did not match my code. Regarding the backend, the most complicated tasks were configuring Jest to work with TypeScript and configuring Prisma to use a test database when performing the integration and End to End tests.",
			"s_desc": "For its part, the biggest challenge in the front was to apply the refresh-token system in terms of authentication with React-Query, since the app had to request a new access token to the server every time an access token expired. On the other hand, configuring React-Query and structuring the app to prevent this library from making repeated requests to the API for component re-rendering was also challenging."
		},
		"learning": {
			"f_desc": "I learned many important concepts during the development of this project. For example, I learned how to apply an authentication system with refresh and access tokens, the difference between the state of the application and the server state or cache, and how to manage and synchronize this server cache with libraries like React-Query. Finally, I improved my ability to configure and synchronize third-party library utilities and learned how to implement internationalization, in addition to all the experience I gained with TypeScript."
		}
	},
	"coroshop": {
		"desc": "Coroshop is a tech e-commerce with administrator options to add, edit or delete products, allowing users to write reviews and pay through PayPal or Stripe.",
		"stack": {
			"f_desc": "I developed this app entirely with TypeScript, which allowed me to reduce errors. In the front, I used React as the base framework and managed the state with Redux Toolkit because it facilitates managing the client state and the server cache with his optional tool RTK Query. On the other hand, I use Styled Components for the UI styles because it facilitates the creation of UI components and does not require any configuration.",
			"s_desc": "For the backend, I choose Nest as the framework because it works by default with TypeScript, allowing the creation of more scalable, testable, and maintainable APIs, and promoting a structure with a good separation of responsibilities. Also, I choose to work with GraphQL instead of a REST API because it is composed of a typed query language that complements very well with TypeScript and generates the API documentation automatically. Finally, I use MongoDB as the database because of its flexibility in defining models and because it's perfect for handling large amounts of data as it scales more cheaply than a relational database."
		},
		"origin": {
			"desc": "Coroshop arises to develop a more complex application both in the backend and frontend, allowing me to practice and consolidate knowledge in the latest libraries or technologies I was learning, such as Nest, GraphQL, or Redux Toolkit with RTK Query. In addition, I also wanted to develop an application to apply a role-based authorization system, in this case, the administrator role."
		},
		"development": {
			"f_desc": "The first version of the backend was an Express and Apollo Server that later would be migrated to Nest because I wanted to have a more robust framework, practice with Nest, and acquire the experience of doing a complete framework migration. In this way, the first phase consisted of configuring Apollo Server with Express, defining the models for MongoDB, and the resolvers that would be in charge of converting GraphQL operations like queries and mutations into data. Then,  I migrated the backend to Nest, creating the resolvers, controllers, and services from the code I already had.",
			"s_desc": "In the case of the front end, I started by defining the route structure that the application would have, to later set up React-Router, Redux, and RTK Query with GraphQL Client. After having the setup ready, I started to develop the pages and components with Styled Components, integrating the Hooks generated by RTK Query to connect the front end with the backend."
		},
		"challenges": {
			"f_desc": "In the backend, the biggest challenge was how and where to implement the authentication and authorization logic since Nest has different levels to place this type of logic, such as middleware, interceptors, or guards. In this sense, I implement a middleware in charge of validating the user's access token to append its information in the request if the access token was valid, to later leave the work of authorization and permissions to the guards.",
			"s_desc": "For its part, the biggest challenge in the front end was configuring RTK Query to work with GraphQL because the base query function for GraphQL provided by RTK Query does not allow the inclusion of credentials in its configuration. To solve this issue, I had to create a new GraphQL client, configure it to include credentials, and then pass it as the base query."
		},
		"learning": {
			"f_desc": "The development of this project helped me to increase my understanding of TypeScript, especially decorators since these are very used in Nest. In addition, it also increased my knowledge of dependency injection and how it eases the process of testing each module. Finally, I learned a better way to organize the folders and files of a project, consisting of grouping the files by feature, which allows me to have the dependencies of modules near each other."
		}
	}
}
