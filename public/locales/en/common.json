{
	"header": {
		"about": "About me",
		"skills": "Skills",
		"projects": "Projects",
		"contact": "Contact me",
		"connect": "Let's connect"
	},
	"hero": {
		"greet": "Hi, I'm",
		"banner": {
			"developer": "Full Stack Developer",
			"engineer": "System Engineer"
		},
		"skills": "I can develop full-stack applications with technologies like JavaScript, TypeScript, React, Node, Express, Nest, PostgreSQL, or MongoDB",
		"cv": "Download CV"
	},
	"about": {
		"title": "About me",
		"first_p": "My programming journey began with my first basic programming classes at college. At that time, I believed programmers were some class of hackers, and my knowledge of web development and programming was practically nil. In this way, the first programming language I learned was C++, where I began to develop basic programs executed in the console to practice the basic programming notions learned so far, as well as more advanced concepts such as object-oriented programming.",
		"second_p": "Later, I began to venture into the world of web development while learning HTML, CSS, and JavaScript to develop more complex programs with more attractive user interfaces. In this way, I decided that I would dedicate myself to web development after practicing with these languages and learning about other technologies such as React and Node, which make it even easier to develop web pages and applications that generate real value for other people. Since then, I began to specialize in this area of programming, learning both self-taught and through courses and bootcamps."
	},
	"skills": {
		"title": "Skills",
		"first_p": "In college, I learned programming and basic software engineering concepts, such as the case of software life cycle, from the analysis of the system to the design and implementation. On the other hand, I have completed",
		"&": "and",
		"second_p": ", in addition to learning other technologies, frameworks, and libraries with free resources such as YouTube.",
		"languages": "Languages",
		"frontend": "Frontend",
		"backend": "Backend",
		"other": "Other"
	},
	"projects": {
		"title": "Projects",
		"action": "View details",
		"web_access": {
			"desc": "Automatic web accessibility evaluation tool and contrast checker"
		},
		"sticky_notes": {
			"desc": "Notes app with internationalization."
		},
		"coroshop": {
			"desc": "E-commerce with Stripe or PayPal payments."
		},
		"time_killer": {
			"desc": "Webapp with several offline games"
		},
		"titles": {
			"origin": "Idea origin",
			"development": "Development process",
			"challenges": "Challenges during development",
			"learning": "Learning"
		},
		"other": "Another projects"
	},
	"contact": {
		"title": "Contact me",
		"form": {
			"f_name": "First name",
			"s_name": "Last name",
			"email": "Email address",
			"message": "Message",
			"send": "Send",
			"success": "Message sent successfully!",
			"fail": "Can not sent message!"
		}
	},
	"footer": {
		"copy": "Copyright by Joan Romero 2022",
		"rights": "All rights reserved"
	},
	"visit": "Live",
	"web_access": {
		"desc": "WebAccess is a website that has two tools to help web developers create more accessible content. The first tool is an automatic web accessibility evaluator, which allows the evaluation of HTML code by inserting the URL of a web page or the HTML code itself, applying up to 13 techniques proposed by the WCAG in its version 2.1. On the other hand, the second tool is a contrast evaluator, which allows knowing if the contrast ratio between two colors (text and background) meets any of the levels established by the WCAG.",
		"stack": {
			"desc": "On the frontend side, I used React as the base framework and SASS for the styles. On the other hand, I developed the backend with Python and Fastapi framework, in addition to a library called BeautifulSoup, which has a simple API to manipulate and analyze the DOM of an HTML document."
		},
		"origin": {
			"desc": "The idea of ​developing an automatic accessibility evaluation tool arose when I was looking for topics to focus on for my thesis at university. While learning web development, I could notice that the subject of accessibility was approached in a limited way or even omitted, so I decided to focus my thesis on this topic. In this way, I researched automatic accessibility evaluation tools and noticed that it was feasible to make a prototype, so I focused my thesis on its development. In this prototype, the evaluation focused on visual disabilities and developed views with EJS, which allows inserting JavaScript code into HTML with Node and Express. Later, to consolidate the knowledge I acquired of React and web development in general, I decided to make a second version, improving the quality of the initial prototype. Finally, I rebuilt the backend with Fastapi because I thought they were better for this kind of web app and to practice with the framework."
		},
		"development": {
			"f_desc": "The first step was to analyze and filter the techniques proposed by the WCAG related to HTML that I could apply with libraries like Cheerio or BeautifulSoup. Subsequently, I began to develop the backend, conformed by a REST API with routes to evaluate by URL and HTML code and each function to test the selected WCAG techniques. It is also important to highlight that I perform unit tests on all techniques functions, besides integration tests on each API route.",
			"s_desc": "As for the front, I started by making a preliminary design in Figma, selecting the color palette and the font styles for the user interfaces built with React and SASS. In this way, the first screens developed were the homepage and the page to select the type of accessibility evaluation. Later, I build the results screen and the logic to handle the API request status. Finally, I did develop the contrast evaluation screen and the necessary stores and logic for the state."
		},
		"challenges": {
			"desc": "Regarding the backend, the main challenge I found was how to perform the functions to apply each WCAG technique with libraries like Cheerio and BeautifulSoup in the most efficient way possible to avoid long API response times. Finally, I found it hard to decide when it was correct to abstract a component to reuse its behavior or style."
		},
		"learning": {
			"f_desc": "I learned good practices during the development of the project. For example, it is always better to have simple code, so you should not be obsessed with performance in the early stages of the project because you could tend to apply over-engineering and write more complex code than necessary. Finally, I learned to perform unit and integration tests and the importance of writing more semantic HTML code, along with other aspects related to web accessibility."
		}
	},
	"sticky_notes": {
		"desc": "Sticky Notes is a note app with the functions of creating, editing, archiving, and deleting notes. In addition, it allows you to assign a color to the notes allowing categorize and filter them, including the ability to search both by title and body of the note. Finally, the application has internationalization (English and Spanish) and a basic JWT-based authentication system.",
		"stack": {
			"f_desc": "I writhe the entire application in TypeScript due to the advantages of having strongly typed code, such as error prevention during development. On the frontend side, I used Vue as the base framework, mainly using Tanstack-Query to manage the state since this library facilitates the coordination and synchronization of the state or cache of the server, which makes up most of the state of the application, plus Pinia to handle the remaining state. For styles, I use Tailwind because it makes it easy to create an attractive and professional user interface in less time, and Headless UI for the interactive parts.",
			"s_desc": "On the other hand, the backend was built on Express due to its ease and flexibility to create a REST API, in addition to PostgreSQL as a database, since it is one of the most robust relational databases with great support. Finally, I use Prisma as ORM because it offers a powerful CLI and works with TypesCript by default, making it easy to create services with good type safety."
		},
		"origin": {
			"desc": "The idea of ​​developing Sticky Notes began to take advantage of a basic notes application that I had made as part of a technical test to practice and consolidate the knowledge I had acquired of technologies such as TypeScript, Tanstack-Query, or Prisma. The original app was written in JavaScript, using Sequelize as the ORM and Bootstrap to style the UI. Also, it is important to point out that the original application did not have an authentication system either."
		},
		"development": {
			"f_desc": "In the development of the first version, it was not necessary to make a preliminary design for the user interface because the test included a basic design, so I focused on preparing the tables for the database. Later, to start with the second version, I begin by migrating the backend code to TypeScript and then redesigning the database to add the necessary tables for the authentication functions and sorting by color. Also, I changed the ORM to Prisma and the drivers and services needed to implement the new features.",
			"s_desc": "In the front, I started by migrating the code to TypeScript and the styles to Material UI, adding interactive components like modal windows. In addition, I added and modified some components to implement authentication, color filtering, search functions, and internationalization. Finally, I decided to change the frontend to Vue to finish reinforcing the knowledge and skills I had gained from this framework, using Tailwind for styles and Pinia to control the application state together with Tanstack-Query."
		},
		"challenges": {
			"f_desc": "One of the biggest challenges I faced was typing third-party library utilities with TypeScript because sometimes they required a specific type that did not match my code. Regarding the backend, the most complicated tasks were configuring Jest to work with TypeScript and configuring Prisma to use a test database when performing the integration and End to End tests in the second version.",
			"s_desc": "For its part, the biggest challenge in the front was to apply the refresh-token system in terms of authentication with Tanstack-Query, since the app had to request a new access token to the server every time an access token expired."
		},
		"learning": {
			"f_desc": "I learned many important concepts during the development of this project. For example, I learned how to apply an authentication system with refresh and access tokens, the difference between the state of the application and the server state or cache, and how to manage and synchronize this server cache with libraries like Tanstack-Query. Finally, I improved my ability to configure and synchronize third-party library utilities and learned how to implement internationalization, in addition to all the experience I gained with TypeScript."
		}
	},
	"coroshop": {
		"desc": "Coroshop is a tech e-commerce with administrator options to add, edit or delete products, allowing users to write reviews and pay through PayPal or Stripe.",
		"stack": {
			"f_desc": "I developed this app entirely with TypeScript, which allowed me to reduce errors. In the front, I used React as the base framework and managed the state with Redux Toolkit because it facilitates managing the client state and the server cache with his optional tool RTK Query. On the other hand, I use Stitches for the UI styles because it facilitates the creation of UI components and does not require any configuration and Radix UI for interactive parts.",
			"s_desc": "For the backend, I choose Nest as the framework because it works by default with TypeScript, allowing the creation of more scalable, testable, and maintainable APIs, and promoting a structure with a good separation of responsibilities. Also, I choose to work with GraphQL instead of a REST API because it is composed of a typed query language that complements very well with TypeScript and generates the API documentation automatically. Finally, I use MongoDB as the database because of its flexibility in defining models and because it's perfect for handling large amounts of data as it scales more cheaply than a relational database."
		},
		"origin": {
			"desc": "Coroshop arises to develop a more complex application both in the backend and frontend, allowing me to practice and consolidate knowledge in the latest libraries or technologies I was learning, such as Nest, GraphQL, or Redux Toolkit with RTK Query. In addition, I also wanted to develop an application to apply a role-based authorization system, in this case, the administrator role."
		},
		"development": {
			"f_desc": "The first version of the backend was an Express and Apollo Server that later would be migrated to Nest because I wanted to have a more robust framework, practice with Nest, and acquire the experience of doing a complete framework migration. In this way, the first phase consisted of configuring Apollo Server with Express, defining the models for MongoDB, and the resolvers that would be in charge of converting GraphQL operations like queries and mutations into data. Then,  I migrated the backend to Nest, creating the resolvers, controllers, and services from the code I already had.",
			"s_desc": "In the case of the front end, I started by defining the route structure that the application would have, to later set up React-Router, Redux, and RTK Query with GraphQL Client. After having the setup ready, I started to develop the pages and components with Stitches, integrating the Hooks generated by RTK Query to connect the front end with the backend."
		},
		"challenges": {
			"f_desc": "In the backend, the biggest challenge was how and where to implement the authentication and authorization logic since Nest has different levels to place this type of logic, such as middleware, interceptors, or guards. In this sense, I implement a middleware in charge of validating the user's access token to append its information in the request if the access token was valid, to later leave the work of authorization and permissions to the guards.",
			"s_desc": "For its part, the biggest challenge in the front end was configuring RTK Query to work with GraphQL because the base query function for GraphQL provided by RTK Query does not allow the inclusion of credentials in its configuration. To solve this issue, I had to create a new GraphQL client, configure it to include credentials, and then pass it as the base query."
		},
		"learning": {
			"f_desc": "The development of this project helped me to increase my understanding of TypeScript, especially decorators since these are very used in Nest. In addition, it also increased my knowledge of dependency injection and how it eases the process of testing each module. Finally, I learned a better way to organize the folders and files of a project, consisting of grouping the files by feature, which allows me to have the dependencies of modules near each other."
		}
	},
	"time_killer": {
		"desc": "Time Killer is a web app that has several offline games such as Simon's game, Snake game, Flappy Bird, Memory, and Tetris. In addition, it allows the user to log in to access the ranking of best scores.",
		"stack": {
			"desc": "I developed the application with Next.js, which uses React as a library to build the interfaces. Also, I use Tailwind CSS for the styles and the hooks available in React to manage the application state. On the other hand, I use Firebase with the Firestore database for the backend."
		},
		"origin": {
			"desc": "I like video games, so I have always wanted to develop or emulate some kind of video game since I started programming. Also, I knew that building this app would allow me to understand the rendering phase of React better, as this is a factor to consider in this library when you want to develop interactive apps with intervals."
		},
		"development": {
			"f_desc": "First, I analyzed similar games that people had developed with react so I could figure out the minigames I would add and get an idea of how to build them. Then, I developed each game and the home page, iterating and refactoring code to improve performance and apply best practices.",
			"s_desc": "Later, I started working on the sessions and authentication system of the application, developing the login and registration views, integrating Firebase, and modeling the documents that would make up the database in Firestore. Finally, I added the logic and components to build the scoring system."
		},
		"challenges": {
			"desc": "During the development of the application, one of the challenges I faced was working with intervals since their closures do not allow values to change. In addition, another problem I faced was the double execution of effects related to React version 18, which caused bugs in games that use intervals, such as Flappy Bird or Tetris."
		},
		"learning": {
			"desc": "Developing this project allowed me to improve my understanding of the rendering phase of React, as well as best practices regarding how to structure and manage application state. Also, I learned to recognize when to use effects and that state changes caused by the user should always go in the event handlers, which allows me to develop clean code and increase the application performance."
		}
	}
}
