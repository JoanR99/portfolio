{
	"header": {
		"about": "Sobre mí",
		"skills": "Habilidades",
		"projects": "Proyectos",
		"contact": "Contáctame",
		"connect": "Vamos a conectar"
	},
	"hero": {
		"greet": "¿Hola que tal? Soy",
		"banner": {
			"developer": "Desarrollador Full Stack",
			"engineer": "Ingeniero de Sistemas"
		},
		"skills": "Puedo desarrollar aplicaciones full stack con tecnologías como JavaScript, TypeScript, React, Node, Express, Nest, PostgreSQL o MongoDB",
		"cv": "Descargar CV"
	},
	"about": {
		"title": "Sobre mí",
		"first_p": "Mi viaje en el mundo de la programación comenzó con las primeras clases de programación básica cursadas en la universidad. Para ese entonces, creía que todos los programadores eran alguna clase de hackers y mi conocimiento en cuanto al desarrollo web y la programación eran prácticamente nulos. De esta manera, el primer lenguaje de programación que aprendí fue C++, donde comencé a desarrollar programas básicos ejecutados en la consola para practicar las nociones básicas de programación aprendidas hasta el momento además de conceptos más avanzados como la programación orientada a objetos.",
		"second_p": "Posteriormente, comencé a incursionar en el mundo del desarrollo web aprendiendo HTML, CSS y JavaScript con el fin de desarrollar programas más complejos y con interfaces de usuario más atractivas. De esta forma, decidí que quería dedicarme al desarrollo web luego de practicar con estos lenguajes y conocer de otras tecnologías como React y Node, las cuales facilitan aún más el desarrollo de páginas y aplicaciones web que generan valor real para otras personas. Desde entonces, comencé a especializarme en esta área de la programación aprendiendo tanto de forma autodidacta como a través de cursos y bootcamps."
	},
	"skills": {
		"title": "Habilidades",
		"first_p": "En la universidad aprendí programación y conceptos básicos de la ingeniería de software, como es el caso del ciclo de vida del software, partiendo desde el análisis hasta el diseño e implementación de sistemas. Por otro lado, he terminado cursos como",
		"&": "y",
		"second_p": ", además de aprender otras tecnologías, frameworks y librerías con recursos gratuitos como es el caso de Youtube.",
		"languages": "Lenguajes",
		"frontend": "Frontend",
		"backend": "Backend",
		"other": "Otros"
	},
	"projects": {
		"title": "Proyectos",
		"action": "Ver proyecto",
		"web_access": {
			"desc": "Herramienta de evaluación automática de accesibilidad web y evaluador de contraste."
		},
		"sticky_notes": {
			"desc": "Aplicación de notas con internacionalización."
		},
		"coroshop": {
			"desc": "E-commerce con pagos en Stripe o PayPal."
		},
		"time_killer": {
			"desc": "Webapp que dispone de varios minijuegos offline"
		},
		"titles": {
			"origin": "Origen de la Idea",
			"development": "Proceso de desarrollo",
			"challenges": "Desafíos durante el desarrollo",
			"learning": "Aprendizaje"
		},
		"other": "Otros proyectos"
	},
	"contact": {
		"title": "Contáctame",
		"form": {
			"f_name": "Nombre",
			"s_name": "Apellido",
			"email": "Dirección email",
			"message": "Mensaje",
			"send": "Enviar",
			"success": "Mensaje enviado!",
			"fail": "No se pudo enviar el mensaje!"
		}
	},
	"footer": {
		"copy": "Copyright por Joan Romero 2022",
		"rights": "Todos los derechos reservados"
	},
	"visit": "Visitar",
	"web_access": {
		"desc": "WebAccess es un sitio web que dispone de dos herramientas con el fin de ayudar a los desarrolladores web a crear contenido más accesible. La primera herramienta se trata de un evaluador automático de accesibilidad web, el cual permite evaluar código HTML insertando el URL de una página web o el propio código HTML, aplicando hasta 13 técnicas propuestas por la WCAG en su versión 2.1. Por otro lado, la segunda herramienta se trata de un evaluador de contraste, el cual permite conocer si la ratio de contraste entre dos colores (texto y fondo) cumple con alguno de los niveles establecidos por la WCAG.",
		"stack": {
			"desc": "En el lado del frontend utilice Svelte como framework base y SASS para los estilos. El backend por su parte fue desarrollado con Python en el framework Fastapi, utilizando la librería BeautifulSoup para analizar el DOM de documentos HTML."
		},
		"origin": {
			"desc": "La idea de desarrollar una herramienta de evaluación automática de accesibilidad surge cuando estaba buscando temas en los que centrarme para realizar la tesis de grado en la universidad. Para ese momento estaba aprendiendo desarrollo web de forma autodidacta y noté que muchas veces se omitía el tema de la accesibilidad o se tocaba de forma muy pobre y general, por lo que decidí centrar mi tesis en esta temática. De esta manera, comencé a investigar sobre herramientas de evaluación automática de accesibilidad y note que, si era factible realizar un prototipo, por lo que centre mi tesis en el desarrollo del mismo. Esta primera versión estaba centrada en discapacidades visuales y las interfaces gráficas fueron desarrolladas utilizando una librería llamada EJS la cual permite insertar código JavaScript en HTML. Posteriormente, para consolidar los conocimientos que adquirí tanto de React como de desarrollo web en general decidí realizar una segunda versión, mejorando la calidad del prototipo inicial. Finalmente, desarrolle esta versión con Svelte y Fastapi para practicar con estas tecnologías y porque me parecían más acordes para este tipo de web app."
		},
		"development": {
			"f_desc": "El primer paso para desarrollar este proyecto fue analizar y filtrar las técnicas propuestas por la WCAG relacionadas a HTML que pudieran ser aplicadas con una librería como Cheerio o BeautifulSoup. Posteriormente, comencé a desarrollar el backend, conformado por un servidor que dispone de una API REST con rutas para evaluar por URL y por código HTML, además de cada una de las funciones para evaluar las técnicas de la WCAG seleccionadas. También es importante resaltar que realice pruebas unitarias a cada una de las funciones que evalúan una técnica, además de pruebas de integración a cada una de las rutas de la API.",
			"s_desc": "En cuanto al frontend, comencé realizando un diseño preliminar en Figma, seleccionando la paleta de colores y los estilos para las interfaces de usuario desarrolladas con Svelte y SASS. De esta manera, las primeras pantallas desarrolladas fueron la homepage y la pagina para seleccionar el tipo de evaluación de accesibilidad. Posteriormente, desarrolle la pantalla de resultados, además de los servicios encargados de manejar el estado de la petición a la API. Finalmente, desarrolle la pantalla de evaluación de contraste además de los stores y lógica necesarios para controlar su estado."
		},
		"challenges": {
			"desc": "En cuanto al backend, el principal reto que encontré estaba relacionado a cómo realizar las funciones para aplicar cada técnica de la WCAG con librerías como Cheerio o BeautifulSoup de la forma más eficiente posible para así evitar que los tiempos de respuesta de la API fueran muy extensos. Finalmente, también fue difícil decidir cuando era correcto abstraer un componente con el fin de reutilizar su funcionamiento o sus estilos."
		},
		"learning": {
			"f_desc": "Durante el desarrollo del proyecto aprendí muchas practicas importantes. Por ejemplo, siempre es mejor tener código simple, por lo que no hay que obsesionarse con la eficiencia en etapas tempranas del proyecto, ya que se puede tender a aplicar sobre-ingeniería y a escribir código más complejo del necesario. Finalmente, aprendí a realizar pruebas unitarias y de integración, así como la importancia de escribir código HTML más semántico, aunado a otros aspectos relacionados a la accesibilidad web."
		}
	},
	"sticky_notes": {
		"desc": "Sticky Notes es una app de notas que dispone de las funciones de crear, editar, archivar y eliminar notas. Además, permite asignar un color a las notas para categorizarlas y filtrarlas, aunado a la capacidad du buscar tanto por título como por cuerpo de la nota. Finalmente, la aplicación cuenta con internacionalización (inglés y español) y un sistema de autenticación básico basado en JWT.",
		"stack": {
			"f_desc": "Escribí toda la aplicación en TypeScript debido a las ventajas que ofrece el tener código fuertemente tipado, como es el caso de la prevención de errores durante el desarrollo. En el lado del frontend utilice Vue como framework base, empleando principalmente Tanstack-Query para manejar el estado de la aplicación, ya que esta librería facilita la coordinación y sincronización del estado o cache del servidor, el cual conforma la mayor parte del estado de la aplicación, además de Pinia para manejar el estado restante. Para los estilos, utilice Tailwind debido a que facilita crear una interfaz de usuario atractiva y profesional en menor tiempo, además de Headless UI para las partes interactivas.",
			"s_desc": "Por su parte, el backend está conformado por un servidor en Fastify, debido a su facilidad y flexibilidad para crear una API REST, además de PostgreSQL como base de datos, ya que es una de las bases de datos relacionales más robustas y con mayor soporte. Finalmente, utilice Prisma como ORM, ya que ofrece un CLI poderoso y trabaja con TypesCript de forma predeterminada, lo que facilita crear servicios con una buena seguridad de tipado."
		},
		"origin": {
			"desc": "La idea de desarrollar Sticky Notes surge para aprovechar una aplicación de notas básica que había realizado como parte de una prueba técnica con el fin de practicar y consolidar los conocimientos que había adquirido de tecnologías como TypeScript, Tanstack-Query o Prisma. La aplicación original estaba escrita en JavaScript, con React en el frontend y Express en el backend, utilizando Sequelize como ORM y Bootstrap para estilar la interfaz de usuario. Además, es importante señalar que la aplicación original tampoco contaba con un sistema de autenticación."
		},
		"development": {
			"f_desc": "En el desarrollo de la primera versión no fue necesario realizar un diseño preliminar para la interfaz de usuario, debido a que la prueba técnica ya definía un diseño básico, por lo que me centre en preparar las tablas para la base de datos. Posteriormente, para iniciar con la segunda versión comencé por migrar el código del backend a TypeScript para después re-diseñar la base de datos y agregar las tablas necesarias para las funciones de autenticación y filtrado por color. Además, migre de Sequelize a Prisma como ORM y agregue o modifique los controlados y servicios necesarios para implementar las nuevas funciones. Luego de un tiempo, decidí migrar el backend de la aplicación de Express a Fastify, debido a que Express dejo de tener soporte y la similitud entre ambos, además de migrar los test de Jest a Vitest.",
			"s_desc": "En el caso del frontend, para la segunda versión comencé por migrar el código a TypeScript y los estilos a Material UI, añadiendo componentes interactivos como las ventanas modales. Además, modifiqué y agregué algunos componentes para implementar las funciones de autenticación, filtrado por color y búsqueda, e internacionalización. Finalmente, al migrar el backend a Fastify decidí migrar el frontend a Vue para terminar de reforzar los conocimientos y habilidades que había obtenido de este framework, utilizando Tailwind para los estilos y Pinia para controlar el estado de la aplicación junto a Tanstack-Query."
		},
		"challenges": {
			"f_desc": "Uno de los mayores retos que enfrente fue el tipado con TypeScript en cuanto a las utilidades de librerías de terceros, debido a que en algunas ocasiones estas requerían tipos que no coincidían con mi código. En cuanto al backend, las tareas más difíciles fueron configurar Jest para trabajar con TypeScript y configurar Prisma para utilizar una base de datos de prueba al realizar los test de integración y End to End en la segunda versión.",
			"s_desc": "Por su parte, el mayor reto en el frontend fue aplicar el sistema de refrescamiento de token en cuanto a la autenticación con Tanstack-Query, ya que se debe pedir un nuevo token de acceso cada vez que una petición se realizara con un token de acceso expirado."
		},
		"learning": {
			"f_desc": "Aprendí muchos conceptos importantes durante el desarrollo de este proyecto. Por ejemplo, cómo aplicar un sistema de autenticación con tokens de refrescamiento y de acceso, comprender la diferencia entre el estado de la aplicación y del estado o cache del servidor y cómo manejar y sincronizar este cache del servidor con librerías como Tanstack-Query. Finalmente, mejoré mi capacidad para configurar y sincronizar utilidades de librerías de terceros y aprendí a implementar internacionalización, sumado a toda la experiencia que obtuve con TypeScript."
		}
	},
	"coroshop": {
		"desc": "Coroshop es un tech e-commerce que cuenta con opciones de administrador para agregar, editar o eliminar productos, además de permitir a usuarios escribir reseñas y pagar a través de PayPal o Stripe.",
		"stack": {
			"f_desc": "Desarrolle la aplicación en su totalidad con TypeScript, lo que permitió evitar errores. En el front, utilice React como framework base, manejando el estado con Redux Toolkit debido a que es una librería que facilita manejar el estado del cliente y el caché del servidor con su complemento opcional RTK Query. Por su parte, para los estilos utilice Stitches, debido que facilita la creación de componentes de UI y no requiere ningún tipo de configuración, además de Radix UI para las partes interactivas.",
			"s_desc": "Por otro lado, el backend está conformado por un servidor en Nest, debido a que trabaja de forma predeterminada con TypeScript, permite crear APIs más escalables, testeables y mantenibles promoviendo una estructura con una buena separación de responsabilidades. Además, decidí trabajar con GraphQL en vez de REST debido a que está compuesto por un lenguaje de consulta tipado que se complementa muy bien con TypeScript y genera la documentación de la API de forma automática. Finalmente, utilice MongoDB como base de datos debido a su flexibilidad para definir los modelos y porque es perfecto para manejar grandes cantidades de información al escalar de forma más económica que una base de datos relacional."
		},
		"origin": {
			"desc": "Coroshop surge con la finalidad de desarrollar una aplicación más compleja tanto en el backend como en el frontend, la cual me permitiera practicar y asentar conocimientos en las ultimas librerías o tecnologías que estaba aprendiendo, como es el caso de Nest, GraphQL o Redux Toolkit con RTK Query. Además, también quería desarrollar una aplicación en la cual aplicar un sistema de autorización basado en roles, en este caso el rol de administrador."
		},
		"development": {
			"f_desc": "La primera versión del backend estaba conformada por un servidor con Express y Apollo Server el cual posteriormente seria migrado a Nest, debido a que quería tener un framework más robusto, practicar con Nest y adquirir la experiencia de hacer una migración de framework completa. De esta manera, la primera fase del proyecto consistió en configurar Apollo Server con Express, definir los modelos para MongoDB y definir los resolvers que se encargarían de convertir las operaciones de GraphQL como queries y mutaciones en data. Posteriormente, migre el backend a Nest, creando los resolvers, controladores y servicios a partir del código que ya tenía.",
			"s_desc": "En el caso del frontend, comencé por definir la estructura de rutas que tendría la aplicación, para posteriormente realizar el setup de React-Router, Redux y de RTK Query con GraphQL Client. Luego de tener el setup listo, comencé a desarrollar las páginas y componentes básicos con Stitches, integrando los Hooks generados por RTK Query para ir conectando el frontend con el backend."
		},
		"challenges": {
			"f_desc": "En el backend el mayor desafió consistió en definir cómo y en donde implementar la lógica de autenticación y autorización, ya que Nest dispone de diferentes niveles en los que colocar este tipo de lógica, como es el caso de los middlewares, interceptores o guardias. En este sentido, implementé un middleware que se encargaría de validar el token de acceso del usuario para anexar la información del mismo en el request en caso de que el token de acceso fuera válido, para posteriormente dejar el trabajo de autorización y permisos a los guardias.",
			"s_desc": "Por su parte, el mayor reto en el frontend fue configurar RTK Query para trabajar con GraphQL, ya que la función base query para GraphQL proveída por RTK Query no permitía incluir credenciales en su configuración. Para resolver este problema, tuve que crear un nuevo cliente de GraphQL configurado para incluir credenciales y posteriormente pasarlo como base query."
		},
		"learning": {
			"f_desc": "El desarrollo de este proyecto me ayudo a aumentar mi entendimiento de TypeScript, sobre todo de los decoradores, ya que estos son bastante utilizados en Nest. Además, también aumente mi comprensión en lo que respecta a la inyección de dependencias y a como esta facilita el proceso de testear cada módulo. Finalmente, aprendí una mejor forma de organizar las carpetas y archivos de un proyecto, consistente en agrupar los archivos por prestación o feature, lo que permite tener las dependencias de cada módulo más cercanas."
		}
	},
	"time_killer": {
		"desc": "Time Killer es una webapp que dispone de varios minijuegos offline como el juego de Simon, la Culebrita, Flappy Bird, Memoria y Tetris. Además, permite al usuario iniciar sesión para acceder al ranking de mejores puntuaciones.",
		"stack": {
			"desc": "La aplicación fue desarrollada con el framework Next el cual utiliza React como librería para desarrollar las interfaces. Para los estilos utilice Tailwind CSS y para manejar el estado de la aplicación utilice los hooks básicos de los que dispone React para realizar custom hooks enfocados en este aspecto. Por su parte, para el backend utilice el BaaS Firebase con su base de datos Firestore."
		},
		"origin": {
			"desc": "Desde siempre me han gustado los videojuegos, por lo que desde que comencé a programar quise desarrollar o emular algún tipo de videojuego interactivo. Además, sabía que el desarrollo de esta aplicación me permitiría comprender de mejor forma la fase de renderizado de React, ya que este es un factor importante a considerar con esta librería cuando se desarrollan aplicaciones interactivas que disponen de intervalos."
		},
		"development": {
			"f_desc": "El primer paso para desarrollar esta aplicación consistió en seleccionar los minijuegos que agregaría, para lo cual me documente en cuanto a los juegos que otras personas habían desarrollado con react. Después, comencé a desarrollar cada uno de los juegos y el home page, iterando y refactorizando código para mejorar el performance o para aplicar mejores prácticas. ",
			"s_desc": "Posteriormente, comencé a trabajar en las sesiones y autenticación de la aplicación, desarrollando las vistas de inicio de sesión y de registro, además de integrar Firebase y modelar los documentos que conformarían la base de datos en Firestore. Finalmente, agregue la lógica y los componentes para integrar el sistema de puntuaciones."
		},
		"challenges": {
			"desc": "Uno de los desafíos que enfrente durante el desarrollo de la aplicación fue comprender como trabajar adecuadamente con intervalos, ya que dentro de los mismos se crean clausuras y por lo tanto los valores no cambian. Además, otro problema que enfrente estuvo relacionado a la característica de React en su versión 18 en delante de ejecutar dos veces los efectos, lo que causaba bugs en los juegos que usan intervalos, como es el caso de Flappy Bird o Tetris."
		},
		"learning": {
			"desc": "El desarrollo de este proyecto me permitió comprender de mejor forma la fase de renderizado de React, así como las mejores prácticas concernientes a como estructurar y manejar el estado de la aplicación. Además, aprendí a reconocer cuando se deben utilizar efectos y que aquellos cambios de estado provocados por el usuario siempre deben ir en los event handlers, lo que permite desarrollar código más limpio y aumenta el performance de la aplicación."
		}
	}
}
