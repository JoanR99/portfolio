{
	"header": {
		"about": "Sobre mí",
		"skills": "Habilidades",
		"projects": "Proyectos",
		"contact": "Contáctame",
		"connect": "Vamos a conectar"
	},
	"hero": {
		"greet": "¿Hola que tal? Soy",
		"banner": {
			"developer": "Desarrollador Full Stack",
			"engineer": "Ingeniero de Sistemas"
		},
		"skills": "Puedo desarrollar aplicaciones full stack con tecnologías como JavaScript, TypeScript, React, Node, Express, Nest, PostgreSQL o MongoDB",
		"cv": "Descargar CV"
	},
	"about": {
		"title": "Sobre mí",
		"first_p": "Mi viaje en el mundo de la programación comenzó en la universidad con las primeras clases de programación básica cursadas. Para ese entonces, creía que todos los programadores eran alguna clase de hackers y mi conocimiento en cuanto al desarrollo web y la programación eran prácticamente nulos. De esta manera, aprendí las nociones básicas de la programación a través del lenguaje C++, desarrollando pequeños programas ejecutados en la consola. Posteriormente, comencé a estudiar HTML, CSS, JavaScript y PHP con el fin de desarrollar programas más complejos y con interfaces de usuario atractivas para cumplir con los proyectos asignados en la universidad.",
		"second_p": "Así, el primer proyecto que realice para practicar estas tecnologías consistió en un pequeño repositorio con el fin de almacenar y organizar información requerida para ayudar a personas a optar a bonos que brinda el gobierno a través de un portal web. Después, al terminar el proyecto, sentí una satisfacción inmensa al ver que podía desarrollar software que fuera de alguna utilidad para otras personas. Desde entonces decidí especializarme en desarrollo web, aprendiendo tanto de forma autodidacta como a través de cursos y bootcamps."
	},
	"skills": {
		"title": "Habilidades",
		"first_p": "En la universidad aprendí programación básica además de conceptos más avanzados como es el caso de la programación orientada a objetos, las estructuras de datos, los algoritmos y la recursividad, aunado a conceptos básicos de la ingeniería de software, como es el caso del ciclo de vida del software, partiendo desde el análisis hasta el diseño e implementación de sistemas. Por otro lado, he terminado cursos como",
		"&": "y",
		"second_p": ", además de aprender otras tecnologías, frameworks y librerías con recursos gratuitos como es el caso de Youtube o de la propia documentación de dichas tecnologías.",
		"languages": "Lenguajes",
		"frontend": "Frontend",
		"backend": "Backend",
		"other": "Otros"
	},
	"projects": {
		"title": "Proyectos",
		"action": "Ver proyecto",
		"web_access": {
			"desc": "Herramienta de evaluación automática de accesibilidad web y evaluador de contraste."
		},
		"sticky_notes": {
			"desc": "Aplicación de notas con internacionalización."
		},
		"coroshop": {
			"desc": "E-commerce con pagos en Stripe o PayPal."
		},
		"titles": {
			"origin": "Origen de la Idea",
			"development": "Proceso de desarrollo",
			"challenges": "Desafíos durante el desarrollo",
			"learning": "Aprendizaje"
		},
		"other": "Otros proyectos"
	},
	"contact": {
		"title": "Contáctame",
		"form": {
			"f_name": "Nombre",
			"s_name": "Apellido",
			"email": "Dirección email",
			"message": "Mensaje",
			"send": "Enviar",
			"success": "Mensaje enviado!",
			"fail": "No se pudo enviar el mensaje!"
		}
	},
	"footer": {
		"copy": "Copyright por Joan Romero 2022",
		"rights": "Todos los derechos reservados"
	},
	"visit": "Visitar",
	"web_access": {
		"desc": "WebAccess es un sitio web que dispone de dos herramientas con el fin de ayudar a los desarrolladores web a crear contenido más accesible. La primera herramienta se trata de un evaluador automático de accesibilidad web, el cual permite evaluar código HTML insertando el URL de una página web o el propio código HTML, aplicando hasta 13 técnicas propuestas por la WCAG en su versión 2.1. Por otro lado, la segunda herramienta se trata de un evaluador de contraste, el cual permite conocer si la ratio de contraste entre dos colores (texto y fondo) cumple con alguno de los niveles establecidos por la WCAG.",
		"stack": {
			"desc": "En el lado del frontend utilice Svelte como framework base y SASS para los estilos. El backend por su parte fue desarrollado con Python en el framework Fastapi, utilizando la librería BeautifulSoup para analizar el DOM de documentos HTML."
		},
		"origin": {
			"desc": "La idea de desarrollar una herramienta de evaluación automática de accesibilidad surge cuando estaba buscando temas en los que centrarme para realizar la tesis de grado en la universidad. Para ese momento estaba aprendiendo desarrollo web de forma autodidacta y noté que muchas veces se omitía el tema de la accesibilidad o se tocaba de forma muy pobre y general, por lo que decidí centrar mi tesis en esta temática. De esta manera, comencé a investigar sobre herramientas de evaluación automática de accesibilidad y note que, si era factible realizar un prototipo, por lo que centre mi tesis en el desarrollo del mismo. Esta primera versión estaba centrada en discapacidades visuales y las interfaces gráficas fueron desarrolladas utilizando una librería llamada EJS la cual permite insertar código JavaScript en HTML. Posteriormente, para consolidar los conocimientos que adquirí tanto de React como de desarrollo web en general decidí realizar una segunda versión, mejorando la calidad del prototipo inicial. Finalmente, desarrolle esta versión con Svelte y Fastapi para practicar con estas tecnologías y porque me parecían más acordes para este tipo de web app."
		},
		"development": {
			"f_desc": "El primer paso para desarrollar este proyecto fue analizar y filtrar las técnicas propuestas por la WCAG relacionadas a HTML que pudieran ser aplicadas con una librería como Cheerio o BeautifulSoup. Posteriormente, comencé a desarrollar el backend, conformado por un servidor que dispone de una API REST con rutas para evaluar por URL y por código HTML, además de cada una de las funciones para evaluar las técnicas de la WCAG seleccionadas. También es importante resaltar que realice pruebas unitarias a cada una de las funciones que evalúan una técnica, además de pruebas de integración a cada una de las rutas de la API.",
			"s_desc": "En cuanto al frontend, comencé realizando un diseño preliminar en Figma, seleccionando la paleta de colores y los estilos para las interfaces de usuario desarrolladas con Svelte y SASS. De esta manera, las primeras pantallas desarrolladas fueron la homepage y la pagina para seleccionar el tipo de evaluación de accesibilidad. Posteriormente, desarrolle la pantalla de resultados, además de los servicios encargados de manejar el estado de la petición a la API. Finalmente, desarrolle la pantalla de evaluación de contraste además de los stores y lógica necesarios para controlar su estado."
		},
		"challenges": {
			"desc": "En cuanto al backend, el principal reto que encontré estaba relacionado a cómo realizar las funciones para aplicar cada técnica de la WCAG con librerías como Cheerio o BeautifulSoup de la forma más eficiente posible para así evitar que los tiempos de respuesta de la API fueran muy extensos. Finalmente, también fue difícil decidir cuando era correcto abstraer un componente con el fin de reutilizar su funcionamiento o sus estilos."
		},
		"learning": {
			"f_desc": "Durante el desarrollo del proyecto aprendí muchas practicas importantes. Por ejemplo, siempre es mejor tener código simple, por lo que no hay que obsesionarse con la eficiencia en etapas tempranas del proyecto, ya que se puede tender a aplicar sobre-ingeniería y a escribir código más complejo del necesario. Finalmente, aprendí a realizar pruebas unitarias y de integración, así como la importancia de escribir código HTML más semántico, aunado a otros aspectos relacionados a la accesibilidad web."
		}
	},
	"sticky_notes": {
		"desc": "Sticky Notes es una app de notas que dispone de las funciones de crear, editar, archivar y eliminar notas. Además, permite asignar un color a las notas para categorizarlas y filtrarlas, aunado a la capacidad du buscar tanto por título como por cuerpo de la nota. Finalmente, la aplicación cuenta con internacionalización (inglés y español) y un sistema de autenticación básico basado en JWT.",
		"stack": {
			"f_desc": "Escribí toda la aplicación en TypeScript debido a las ventajas que ofrece el tener código fuertemente tipado, como es el caso de la prevención de errores durante el desarrollo. En el lado del frontend utilice Vue como framework base, empleando principalmente Tanstack-Query para manejar el estado de la aplicación, ya que esta librería facilita la coordinación y sincronización del estado o cache del servidor, el cual conforma la mayor parte del estado de la aplicación, además de Pinia para manejar el estado restante. Para los estilos, utilice Tailwind debido a que facilita crear una interfaz de usuario atractiva y profesional en menor tiempo.",
			"s_desc": "Por su parte, el backend está conformado por un servidor en Fastify, debido a su facilidad y flexibilidad para crear una API REST, además de PostgreSQL como base de datos, ya que es una de las bases de datos relacionales más robustas y con mayor soporte. Finalmente, utilice Prisma como ORM, ya que ofrece un CLI poderoso y trabaja con TypesCript de forma predeterminada, lo que facilita crear servicios con una buena seguridad de tipado."
		},
		"origin": {
			"desc": "La idea de desarrollar Sticky Notes surge para aprovechar una aplicación de notas básica que había realizado como parte de una prueba técnica con el fin de practicar y consolidar los conocimientos que había adquirido de tecnologías como TypeScript, Tanstack-Query o Prisma. La aplicación original estaba escrita en JavaScript, con React en el frontend y Express en el backend, utilizando Sequelize como ORM y Bootstrap para estilar la interfaz de usuario. Además, es importante señalar que la aplicación original tampoco contaba con un sistema de autenticación."
		},
		"development": {
			"f_desc": "En el desarrollo de la primera versión no fue necesario realizar un diseño preliminar para la interfaz de usuario, debido a que la prueba técnica ya definía un diseño básico, por lo que me centre en preparar las tablas para la base de datos. Posteriormente, para iniciar con la segunda versión comencé por migrar el código del backend a TypeScript para después re-diseñar la base de datos y agregar las tablas necesarias para las funciones de autenticación y filtrado por color. Además, migre de Sequelize a Prisma como ORM y agregue o modifique los controlados y servicios necesarios para implementar las nuevas funciones. Luego de un tiempo, decidí migrar el backend de la aplicación de Express a Fastify, debido a que Express dejo de tener soporte y la similitud entre ambos, además de migrar los test de Jest a Vitest.",
			"s_desc": "En el caso del frontend, para la segunda versión comencé por migrar el código a TypeScript y los estilos a Material UI, añadiendo componentes interactivos como las ventanas modales. Además, modifiqué y agregué algunos componentes para implementar las funciones de autenticación, filtrado por color y búsqueda, e internacionalización. Finalmente, al migrar el backend a Fastify decidí migrar el frontend a Vue para terminar de reforzar los conocimientos y habilidades que había obtenido de este framework, utilizando Tailwind para los estilos y Pinia para controlar el estado de la aplicación junto a Tanstack-Query."
		},
		"challenges": {
			"f_desc": "Uno de los mayores retos que enfrente fue el tipado con TypeScript en cuanto a las utilidades de librerías de terceros, debido a que en algunas ocasiones estas requerían tipos que no coincidían con mi código. En cuanto al backend, las tareas más difíciles fueron configurar Jest para trabajar con TypeScript y configurar Prisma para utilizar una base de datos de prueba al realizar los test de integración y End to End en la segunda versión.",
			"s_desc": "Por su parte, el mayor reto en el frontend fue aplicar el sistema de refrescamiento de token en cuanto a la autenticación con Tanstack-Query, ya que se debe pedir un nuevo token de acceso cada vez que una petición se realizara con un token de acceso expirado."
		},
		"learning": {
			"f_desc": "Aprendí muchos conceptos importantes durante el desarrollo de este proyecto. Por ejemplo, cómo aplicar un sistema de autenticación con tokens de refrescamiento y de acceso, comprender la diferencia entre el estado de la aplicación y del estado o cache del servidor y cómo manejar y sincronizar este cache del servidor con librerías como Tanstack-Query. Finalmente, mejoré mi capacidad para configurar y sincronizar utilidades de librerías de terceros y aprendí a implementar internacionalización, sumado a toda la experiencia que obtuve con TypeScript."
		}
	},
	"coroshop": {
		"desc": "Coroshop es un tech e-commerce que cuenta con opciones de administrador para agregar, editar o eliminar productos, además de permitir a usuarios escribir reseñas y pagar a través de PayPal o Stripe.",
		"stack": {
			"f_desc": "Desarrolle la aplicación en su totalidad con TypeScript, lo que permitió evitar errores. En el front, utilice React como framework base, manejando el estado con Redux Toolkit debido a que es una librería que facilita manejar el estado del cliente y el caché del servidor con su complemento opcional RTK Query. Por su parte, para los estilos utilice Styled Components, debido que facilita la creación de componentes de UI y no requiere ningún tipo de configuración.",
			"s_desc": "Por otro lado, el backend está conformado por un servidor en Nest, debido a que trabaja de forma predeterminada con TypeScript, permite crear APIs más escalables, testeables y mantenibles promoviendo una estructura con una buena separación de responsabilidades. Además, decidí trabajar con GraphQL en vez de REST debido a que está compuesto por un lenguaje de consulta tipado que se complementa muy bien con TypeScript y genera la documentación de la API de forma automática. Finalmente, utilice MongoDB como base de datos debido a su flexibilidad para definir los modelos y porque es perfecto para manejar grandes cantidades de información al escalar de forma más económica que una base de datos relacional."
		},
		"origin": {
			"desc": "Coroshop surge con la finalidad de desarrollar una aplicación más compleja tanto en el backend como en el frontend, la cual me permitiera practicar y asentar conocimientos en las ultimas librerías o tecnologías que estaba aprendiendo, como es el caso de Nest, GraphQL o Redux Toolkit con RTK Query. Además, también quería desarrollar una aplicación en la cual aplicar un sistema de autorización basado en roles, en este caso el rol de administrador."
		},
		"development": {
			"f_desc": "La primera versión del backend estaba conformada por un servidor con Express y Apollo Server el cual posteriormente seria migrado a Nest, debido a que quería tener un framework más robusto, practicar con Nest y adquirir la experiencia de hacer una migración de framework completa. De esta manera, la primera fase del proyecto consistió en configurar Apollo Server con Express, definir los modelos para MongoDB y definir los resolvers que se encargarían de convertir las operaciones de GraphQL como queries y mutaciones en data. Posteriormente, migre el backend a Nest, creando los resolvers, controladores y servicios a partir del código que ya tenía.",
			"s_desc": "En el caso del frontend, comencé por definir la estructura de rutas que tendría la aplicación, para posteriormente realizar el setup de React-Router, Redux y de RTK Query con GraphQL Client. Luego de tener el setup listo, comencé a desarrollar las páginas y componentes básicos con Styled Componentes, integrando los Hooks generados por RTK Query para ir conectando el frontend con el backend."
		},
		"challenges": {
			"f_desc": "En el backend el mayor desafió consistió en definir cómo y en donde implementar la lógica de autenticación y autorización, ya que Nest dispone de diferentes niveles en los que colocar este tipo de lógica, como es el caso de los middlewares, interceptores o guardias. En este sentido, implementé un middleware que se encargaría de validar el token de acceso del usuario para anexar la información del mismo en el request en caso de que el token de acceso fuera válido, para posteriormente dejar el trabajo de autorización y permisos a los guardias.",
			"s_desc": "Por su parte, el mayor reto en el frontend fue configurar RTK Query para trabajar con GraphQL, ya que la función base query para GraphQL proveída por RTK Query no permitía incluir credenciales en su configuración. Para resolver este problema, tuve que crear un nuevo cliente de GraphQL configurado para incluir credenciales y posteriormente pasarlo como base query."
		},
		"learning": {
			"f_desc": "El desarrollo de este proyecto me ayudo a aumentar mi entendimiento de TypeScript, sobre todo de los decoradores, ya que estos son bastante utilizados en Nest. Además, también aumente mi comprensión en lo que respecta a la inyección de dependencias y a como esta facilita el proceso de testear cada módulo. Finalmente, aprendí una mejor forma de organizar las carpetas y archivos de un proyecto, consistente en agrupar los archivos por prestación o feature, lo que permite tener las dependencias de cada módulo más cercanas."
		}
	}
}
